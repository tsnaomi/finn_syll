{% extends 'base.html' %}

{% block head %}
<link href='//fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
{% endblock %}

{% block body %}
<div class='markdown'> 
{% filter markdown %}

# Syllabification rules

**T0**:
Indicates that no syllabification rules have applied.

**T1**:
There is a syllable boundary in front of every CV-sequence. If there is a legal consonant cluster, the first consonant of the cluster forms the coda of a stressed syllable; otherwise, the cluster forms the onset of an unstressed syllable.

        def apply_T1(word):
            # split consonants and vowels: 'balloon' -> ['b', 'a', 'll', 'oo', 'n']
            WORD = [w for w in re.split('([ieAyOauo]+)', word) if w]
            count = 0
            for i, v in enumerate(WORD):
                if i == 0 and is_consonant(v[0]):
                    continue
                elif is_consonant(v[0]) and i + 1 != len(WORD):
                    if is_cluster(v):  # WSP
                        if count % 2 == 0:
                            WORD[i] = v[0] + '.' + v[1:]  # CC > C.C, CCC > C.CC
                        else:
                            WORD[i] = '.' + v  # CC > .CC, CCC > .CCC
                    else:
                        WORD[i] = v[:-1] + '.' + v[-1]  # CC > C.C, CCC > CC.C
                    count += 1
            WORD = ''.join(WORD)
            return WORD

**T2**:
There is a syllable boundary within a sequence VV of two nonidentical vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].

        def apply_T2(word):
            WORD = word
            offset = 0
            for vv in vv_sequences(WORD):
                seq = vv.group(2)
                if not is_diphthong(seq) and not is_long(seq):
                    i = vv.start(2) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T8**:
Split /ie/ sequences in syllables that do not take primary stress.

        def apply_T8(word):
            WORD = word
            offset = 0
            for ie in ie_sequences(WORD):
                i = ie.start(1) + 1 + offset
                WORD = WORD[:i] + '.' + WORD[i:]
                offset += 1
            return WORD

**T9**:
Split /iu/ sequences that do not appear in the first, second, or final syllables.
        
        def apply_T9(word):
            WORD = word
            index = 0
            offset = 0
            for iu in iu_sequences(WORD):
                if iu.start(1) != index:
                    i = iu.start(1) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    index = iu.start(1)
                    offset += 1
            return WORD, RULE

**T4**:
An agglutination diphthong that ends in /u, y/ usually contains a syllable boundary when -C# or -CCV follow, e.g., [lau.ka.us], [va.ka.ut.taa].

        def apply_T4(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                # i % 2 != 0 prevents this rule from applying to first, third, etc.
                # syllables, which receive stress (WSP)
                if is_consonant(v[-1]) and i % 2 != 0:
                    if i + 1 == len(WORD) or is_consonant(WORD[i + 1][0]):
                        vv = u_or_y_final_diphthongs(v)
                        if vv and not is_long(vv.group(1)):
                            I = vv.start(1) + 1
                            WORD[i] = v[:I] + '.' + v[I:]
            WORD = '.'.join(WORD)
            return WORD

**T6**:
If a VVV-sequence contains a long vowel, there is a syllable boundary between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.öön], [ruu.an], [mää.yt.te].

        def apply_T6(word):
            WORD = word
            offset = 0
            for vvv in vvv_sequences(WORD):
                seq = vvv.group(2)
                j = 2 if is_long(seq[:2]) else 1 if is_long(seq[1:]) else 0
                if j:
                    i = vvv.start(2) + j + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T5**:
If a (V)VVV-sequence contains a VV-sequence that could be an /i/-final diphthong, there is a syllable boundary between it and the third vowel, e.g., [raa.ois.sa], [huo.uim.me], [la.eis.sa], [sel.vi.äi.si], [tai.an], [säi.e], [oi.om.me].

        def apply_T5(word):
            WORD = word
                offset = 0
                for vi in i_final_diphthong_vvv_sequences(WORD):
                    s = max(vi.start(1), vi.start(2))
                    i = 2 if s + 2 < len(word) and is_vowel(word[s + 2]) else 0
                    if not (s == i == 0):
                        i += s + offset
                        WORD = WORD[:i] + '.' + WORD[i:]
                        offset += 1
                return WORD

**T7**:
If a VVV-sequence does not contain a potential /i/-final diphthong, there is a syllable boundary between the second and third vowels, e.g. [kau.an], [leu.an], [kiu.as].

        def apply_T7(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                if contains_VVV(v):
                    for I, V in enumerate(v[::-1]):
                        if is_vowel(V):
                            WORD[i] = v[:I] + '.' + v[I:]
            word = '.'.join(WORD)
            return word

**T2**:
There is a syllable boundary within a sequence VV of two nonidentical vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].

        def apply_T2(word):
            WORD = word
            offset = 0
            for vv in vv_sequences(WORD):
                seq = vv.group(2)
                if not is_diphthong(seq) and not is_long(seq):
                    i = vv.start(2) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD


**Regular expression patterns**:

        def vv_sequences(word):
            # this pattern searches for any VV sequence that is not directly preceded
            # or followed by a vowel, and will not match any /ay/ sequence
            pattern = r'(?=(^|\.)[^ieAyOauo]*((?!ay)[ieAyOauo]{2})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def vvv_sequences(word):
            # this pattern searches for any VVV sequence that is not directly preceded
            # or followed by a vowel
            pattern = r'(?=(^|\.)[^ieAyOauo]*([ieAyOauo]{3})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def ie_sequences(word):
            # this pattern searches for any /ie/ sequence that does not occur in the
            # first syllable, and that is not directly preceded or followed by a vowel
            pattern = r'(?=\.[^ieAyOauo]*(ie)[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def iu_sequences(word):
            # this pattern searches for any /iu/ sequence that does do occur in the
            # first, second, or final syllables, and that is not directly preceded or
            # followed by a vowel
            pattern = r'\..+\.[^ieAyOauo]*(iu)[^ieAyOauo]*\.'
            return re.finditer(pattern, word)

        def i_final_diphthong_vvv_sequences(word):
            # this pattern searches for any (V)VVV sequence that contains an i-final
            # diphthong: 'ai', 'ei', 'oi', 'Ai', 'Oi', 'ui', 'yi'
            pattern = r'[ieAyOauo]+([eAyOauo]{1}i)[ieAyOauo]*'
            pattern += r'|[ieAyOauo]*([eAyOauo]{1}i)[ieAyOauo]+'
            return re.finditer(pattern, word)

        def u_or_y_final_diphthongs(word):
            # this pattern searchs for any VV sequence that ends in /u/ or /y/ (incl.
            # long vowels), and that is not directly preceded or followed by a vowel
            return re.search(r'^[^ieAyOauo]*([ieAyOao]{1}(u|y))[^ieAyOauo]*$', word)
  
{% endfilter %}
</div>
{% endblock %}

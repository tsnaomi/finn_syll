{% extends 'base.html' %}

{% block head %}
<link href='//fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
{% endblock %}

{% block body %}
<div class="markdown"> 
{% filter markdown %}

# Syllabification rules

**T1**:
There is a syllable boundary in front of every CV-sequence.

        def apply_T1(word):
            # split consonants and vowels: 'balloon' -> ['b', 'a', 'll', 'oo', 'n']
            WORD = [w for w in re.split('([ieAyOauo]+)', word) if w]
            for i, v in enumerate(WORD):
                if i == 0 and is_consonant(v[0]):
                    continue
                elif is_consonant(v[0]) and i + 1 != len(WORD):
                    WORD[i] = v[:-1] + '.' + v[-1]
            WORD = ''.join(WORD)
            return WORD

**T2**:
There is a syllable boundary within a sequence VV of two nonidentical vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].

        def apply_T2(word):
            WORD = word
            offset = 0
            for vv in vv_sequences(WORD):
                seq = vv.group(2)
                if not is_diphthong(seq) and not is_long(seq):
                    i = vv.start(2) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T8**:
Split /ie/ sequences in syllables that do not take primary stress.

        def apply_T8(word):
            WORD = word
            offset = 0
            for ie in ie_sequences(WORD):
                i = ie.start(1) + 1 + offset
                WORD = WORD[:i] + '.' + WORD[i:]
                offset += 1
            return WORD

**T4**:
An agglutination diphthong that ends in /u, y/ usually contains a syllable boundary when -C# or -CCV follow, e.g., [lau.ka.us], [va.ka.ut.taa].

        def apply_T4(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                # i % 2 != 0 prevents this rule from applying to first, third, etc.
                # syllables, which receive stress (WSP)
                if is_consonant(v[-1]) and i % 2 != 0:
                    if i + 1 == len(WORD) or is_consonant(WORD[i + 1][0]):
                        vv = u_or_y_final_diphthongs(v)
                        if vv and not is_long(vv.group(1)):
                            I = vv.start(1) + 1
                            WORD[i] = v[:I] + '.' + v[I:]
            WORD = '.'.join(WORD)
            return WORD

**T6**:
If a VVV-sequence contains a long vowel, there is a syllable boundary between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.öön], [ruu.an], [mää.yt.te].

        def apply_T6(word):
            WORD = word
            offset = 0
            for vvv in vvv_sequences(WORD):
                seq = vvv.group(2)
                j = 2 if is_long(seq[:2]) else 1 if is_long(seq[1:]) else 0
                if j:
                    i = vvv.start(2) + j + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T5**:
If a (V)VVV-sequence contains a VV-sequence that could be an /i/-final diphthong, there is a syllable boundary between it and the third vowel, e.g., [raa.ois.sa], [huo.uim.me], [la.eis.sa], [sel.vi.äi.si], [tai.an], [säi.e], [oi.om.me].

        def apply_T5(word):
            WORD = word
                offset = 0
                for vi in i_final_diphthong_vvv_sequences(WORD):
                    s = max(vi.start(1), vi.start(2))
                    i = 2 if s + 2 < len(word) and is_vowel(word[s + 2]) else 0
                    if not (s == i == 0):
                        i += s + offset
                        WORD = WORD[:i] + '.' + WORD[i:]
                        offset += 1
                return WORD

**T7**:
If a VVV-sequence does not contain a potential /i/-final diphthong, there is a syllable boundary between the second and third vowels, e.g. [kau.an], [leu.an], [kiu.as].

        def apply_T7(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                if contains_VVV(v):
                    for I, V in enumerate(v[::-1]):
                        if is_vowel(V):
                            WORD[i] = v[:I] + '.' + v[I:]
            word = '.'.join(WORD)
            return word

**Regular expression patterns**:

        def vv_sequences(word):
            # this pattern searches for any VV sequence that is not directly preceded
            # or followed by a vowel, and will not match any /ay/ sequence
            pattern = r'(?=(^|\.)[^ieAyOauo]*((?!ay)[ieAyOauo]{2})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)


        def vvv_sequences(word):
            # this pattern searches for any VVV sequence that is not directly preceded
            # or followed by a vowel
            pattern = r'(?=(^|\.)[^ieAyOauo]*([ieAyOauo]{3})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)


        def ie_sequences(word):
            # this pattern searches for any /ie/ sequence that does not occur in the
            # first syllable, and that is not directly preceded or followed by a vowel
            pattern = r'(?=\.[^ieAyOauo]*(ie)[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)


        def i_final_diphthong_vvv_sequences(word):
            # this pattern searches for any (V)VVV sequence that contains an i-final
            # diphthong: 'ai', 'ei', 'oi', 'Ai', 'Oi', 'ui', 'yi'
            pattern = r'[ieAyOauo]+([eAyOauo]{1}i)[ieAyOauo]*'
            pattern += r'|[ieAyOauo]*([eAyOauo]{1}i)[ieAyOauo]+'
            return re.finditer(pattern, word)


        def u_or_y_final_diphthongs(word):
            # this pattern searchs for any VV sequence that ends in /u/ or /y/ (incl.
            # long vowels), and that is not directly preceded or followed by a vowel
            return re.search(r'^[^ieAyOauo]*([ieAyOao]{1}(u|y))[^ieAyOauo]*$', word)
  
# Notes  
        
- Consider flipping rule order (i.e., do not alter a boundary once it is imposed).

{% endfilter %}
</div>
<br>
{% endblock %}

so.pe.ut.ti
te.ra.peut.ti -- third syllable receives secondary
le.uh.ka --> leuh.ka
ta.[k]us.taa


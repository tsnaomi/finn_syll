{% extends 'base.html' %}

{% block head %}
<link href='//fonts.googleapis.com/css?family=Droid+Sans+Mono' rel='stylesheet' type='text/css'>
{% endblock %}

{% block body %}
<div class='markdown'> 
{% filter markdown %}

# Syllabification rules

**T0**:
Indicates that no syllabification rules have applied.

**T1b**: If there is a consonant cluster word-initially, the entire cluster forms the onset of the first syllable.

**T1c**: If there is a consonant cluster word-finally, the entire cluster forms the coda of the final syllable.

**T1d**: If there is a bare "Finnish" consonant cluster word-medially and the previous syllable receives stress, the first consonant of the cluster forms the coda of the previous syllable (to create a heavy syllable); otherwise, the whole cluster forms the onset of the current syllable (this is the /kr/ rule).

**T1e**: If there is a word-medial "Finnish" consonant cluster that is preceded by a sonorant consonant, if the previous syllable receives stress, the sonorant consonant and the first consonant of the cluster form the coda of the previous syllable, and the remainder of the cluster forms the onset of the current syllable. *VARIATION: T1e optionally applies.*

**T1f**: If there is a word-medial "Finnish" cluster that follows a consonant, that first consonant forms the coda of the previous syllable, and the cluster forms the onset of the current syllable. T1e bleeds T1f.

**T1a**: There is a syllable boundary in front of every CV sequence.


        def apply_T1(word, T1E=True):
            # split consonants and vowels: 'balloon' -> ['b', 'a', 'll', 'oo', 'n']
            WORD = [w for w in re.split('([ieAyOauo]+)', word) if w]
            count = 1  # a count divisible by 2 indicates an even syllable
            for i, v in enumerate(WORD):
                # T1B
                if i == 0 and is_consonant(v[0]):
                    pass
                elif is_consonant(v[0]):
                    count += 1
                    # True if the current syllable is unstressed, else False
                    unstressed = count % 2 == 0
                    # T1C
                    if i + 1 == len(WORD):
                        pass
                    # T1D
                    elif is_cluster(v):
                        # if the previous syllable is odd and receives stress
                        if unstressed:
                            WORD[i] = v[0] + '.' + v[1:]
                        else:
                            WORD[i] = '.' + v
                    elif is_cluster(v[1:]):
                        # T1E (optional)
                        if T1E and is_sonorant(v[0]) and unstressed:
                            WORD[i] = v[:2] + '.' + v[2:]
                        # T1F
                        else:
                            WORD[i] = v[0] + '.' + v[1:]
                    # T1A
                    else:
                        WORD[i] = v[:-1] + '.' + v[-1]
            WORD = ''.join(WORD)
            return WORD

**T2**:
There is a syllable boundary within a sequence VV of two nonidentical vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].

        def apply_T2(word):
            WORD = word
            offset = 0
            for vv in vv_sequences(WORD):
                seq = vv.group(2)
                if not is_diphthong(seq) and not is_long(seq):
                    i = vv.start(2) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T8**:
Split /ie/ sequences in syllables that do not take primary stress.

        def apply_T8(word):
            WORD = word
            offset = 0
            for ie in ie_sequences(WORD):
                i = ie.start(1) + 1 + offset
                WORD = WORD[:i] + '.' + WORD[i:]
                offset += 1
            return WORD

**T9**:
Split /iu/ sequences that do not appear in the first, second, or final syllables.
        
        def apply_T9(word):
            WORD = word
            index = 0
            offset = 0
            for iu in iu_sequences(WORD):
                if iu.start(1) != index:
                    i = iu.start(1) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    index = iu.start(1)
                    offset += 1
            return WORD, RULE

**T4**:
An agglutination diphthong that ends in /u, y/ usually contains a syllable boundary when -C# or -CCV follow, e.g., [lau.ka.us], [va.ka.ut.taa]. *VARIATION: T4 optionally applies.*

        def apply_T4(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                # i % 2 != 0 prevents this rule from applying to first, third, etc.
                # syllables, which receive stress (WSP)
                if is_consonant(v[-1]) and i % 2 != 0:
                    if i + 1 == len(WORD) or is_consonant(WORD[i + 1][0]):
                        vv = u_or_y_final_diphthongs(v)
                        if vv and not is_long(vv.group(1)):
                            I = vv.start(1) + 1
                            WORD[i] = v[:I] + '.' + v[I:]
            WORD = '.'.join(WORD)
            return WORD

**T6**:
If a VVV-sequence contains a long vowel, there is a syllable boundary between it and the third vowel, e.g. [kor.ke.aa], [yh.ti.öön], [ruu.an], [mää.yt.te].

        def apply_T6(word):
            WORD = word
            offset = 0
            for vvv in vvv_sequences(WORD):
                seq = vvv.group(2)
                j = 2 if is_long(seq[:2]) else 1 if is_long(seq[1:]) else 0
                if j:
                    i = vvv.start(2) + j + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD

**T5**:
If a (V)VVV-sequence contains a VV-sequence that could be an /i/-final diphthong, there is a syllable boundary between it and the third vowel, e.g., [raa.ois.sa], [huo.uim.me], [la.eis.sa], [sel.vi.äi.si], [tai.an], [säi.e], [oi.om.me].

        def apply_T5(word):
            WORD = word
                offset = 0
                for vi in i_final_diphthong_vvv_sequences(WORD):
                    s = max(vi.start(1), vi.start(2))
                    i = 2 if s + 2 < len(word) and is_vowel(word[s + 2]) else 0
                    if not (s == i == 0):
                        i += s + offset
                        WORD = WORD[:i] + '.' + WORD[i:]
                        offset += 1
                return WORD

**T7**:
If a VVV-sequence does not contain a potential /i/-final diphthong, there is a syllable boundary between the second and third vowels, e.g. [kau.an], [leu.an], [kiu.as].

        def apply_T7(word):
            WORD = word.split('.')
            for i, v in enumerate(WORD):
                if contains_VVV(v):
                    for I, V in enumerate(v[::-1]):
                        if is_vowel(V):
                            WORD[i] = v[:I] + '.' + v[I:]
            word = '.'.join(WORD)
            return word

**T2**:
There is a syllable boundary within a sequence VV of two nonidentical vowels that are not a genuine diphthong, e.g., [ta.e], [ko.et.taa].

        def apply_T2(word):
            WORD = word
            offset = 0
            for vv in vv_sequences(WORD):
                seq = vv.group(2)
                if not is_diphthong(seq) and not is_long(seq):
                    i = vv.start(2) + 1 + offset
                    WORD = WORD[:i] + '.' + WORD[i:]
                    offset += 1
            return WORD


**Regular expression patterns**:

        def vv_sequences(word):
            # this pattern searches for any VV sequence that is not directly preceded
            # or followed by a vowel, and will not match any /ay/ sequence
            pattern = r'(?=(^|\.)[^ieAyOauo]*((?!ay)[ieAyOauo]{2})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def vvv_sequences(word):
            # this pattern searches for any VVV sequence that is not directly preceded
            # or followed by a vowel
            pattern = r'(?=(^|\.)[^ieAyOauo]*([ieAyOauo]{3})[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def ie_sequences(word):
            # this pattern searches for any /ie/ sequence that does not occur in the
            # first syllable, and that is not directly preceded or followed by a vowel
            pattern = r'(?=\.[^ieAyOauo]*(ie)[^ieAyOauo]*($|\.))'
            return re.finditer(pattern, word)

        def iu_sequences(word):
            # this pattern searches for any /iu/ sequence that does do occur in the
            # first, second, or final syllables, and that is not directly preceded or
            # followed by a vowel
            pattern = r'\..+\.[^ieAyOauo]*(iu)[^ieAyOauo]*\.'
            return re.finditer(pattern, word)

        def i_final_diphthong_vvv_sequences(word):
            # this pattern searches for any (V)VVV sequence that contains an i-final
            # diphthong: 'ai', 'ei', 'oi', 'Ai', 'Oi', 'ui', 'yi'
            pattern = r'[ieAyOauo]+([eAyOauo]{1}i)[ieAyOauo]*'
            pattern += r'|[ieAyOauo]*([eAyOauo]{1}i)[ieAyOauo]+'
            return re.finditer(pattern, word)

        def u_or_y_final_diphthongs(word):
            # this pattern searchs for any VV sequence that ends in /u/ or /y/ (incl.
            # long vowels), and that is not directly preceded or followed by a vowel
            return re.search(r'^[^ieAyOauo]*([ieAyOao]{1}(u|y))[^ieAyOauo]*$', word)
  
{% endfilter %}
</div>
{% endblock %}
